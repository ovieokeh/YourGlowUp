<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ClariTree AI - Minimal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        background-color: #f8fafc; /* Tailwind gray-50 */
        color: #334155; /* Tailwind slate-700 */
      }
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.2s ease-in-out;
      }
      .modal-content {
        background-color: white;
        padding: 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        min-width: 300px;
        max-width: 450px;
        transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
      }

      .node {
        cursor: default;
        transition: all 0.2s ease-out;
        fill: #fff;
        stroke: #64748b; /* slate-500 */
        stroke-width: 1.5px;
      }
      .node.highlighted-node {
        stroke: #4f46e5; /* indigo-600 */
        stroke-width: 2.5px;
        box-shadow: 0 0 15px rgba(79, 70, 229, 0.3);
      }
      .node-text {
        font-size: 11px;
        fill: #1e293b; /* slate-800 */
        pointer-events: none;
        user-select: none;
        font-weight: 500;
      }
      .option-item {
        transition: background-color 0.15s ease-in-out;
        border-radius: 0.25rem;
      }
      .option-item:hover {
        background-color: #eef2ff; /* indigo-50 */
      }
      .option-text {
        font-size: 10px;
        fill: #334155; /* slate-700 */
        cursor: pointer;
      }
      .option-text:hover {
        fill: #4f46e5; /* indigo-600 */
      }

      .edge {
        stroke: #cbd5e1; /* slate-300 */
        stroke-width: 1px;
        transition: stroke 0.2s ease;
      }
      .edge.highlighted-edge {
        stroke: #818cf8; /* indigo-400 */
        stroke-width: 2px;
      }
      .desaturated {
        opacity: 0.6;
      }

      .canvas-container {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #f8fafc; /* gray-50 */
        position: relative;
      }
      .notes-input {
        font-size: 0.7rem;
        padding: 0.2rem;
        border: 1px solid #e2e8f0; /* slate-200 */
        border-radius: 0.25rem;
        margin-top: 1px;
        width: calc(100% - 8px);
        background-color: #f8fafc;
      }

      /* Minimal Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #f1f5f9; /* slate-100 */
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; /* slate-300 */
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; /* slate-400 */
      }

      .fade-enter-active {
        opacity: 1;
        transition: opacity 200ms;
      }
      .fade-exit-active {
        opacity: 0;
        transition: opacity 200ms;
      }
      .slide-up-enter-active {
        transform: translateY(0);
        opacity: 1;
        transition: transform 200ms, opacity 200ms;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useCallback, useMemo, useRef, createContext, useContext } = React;

      // --- Constants & Utility Functions & Icons ---
      const OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";
      const DEFAULT_MODEL = "gpt-4o";

      function generateUUID() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) =>
          (c === "x" ? (Math.random() * 16) | 0 : ((Math.random() * 16) & 0x3) | 0x8).toString(16)
        );
      }

      // Heroicons (as JSX components for simplicity)
      const CogIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          className="w-5 h-5"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5.75l-2.25-1.313M3.75 11.25l2.25 1.313m0-2.626l2.25-1.313M6 9.75l2.25 1.313M18 9.75l-2.25 1.313m0 2.626l-2.25 1.313M12 6.75l2.25 1.313m0 2.626l-2.25 1.313M12 3.75l2.25 1.313m0 2.626l-2.25 1.313M6 6.75l2.25-1.313M18 6.75l-2.25-1.313M12 14.25l-2.25 1.313M12 17.25l-2.25 1.313M12 20.25l-2.25 1.313m2.25-2.626l2.25 1.313M15 15.75a3 3 0 01-3 3M15 12a3 3 0 01-3 3m-3-3a3 3 0 00-3-3m3 3a3 3 0 01-3 3m0 0a3 3 0 003 3m-3-3H9m6 0h1.5"
          />
        </svg>
      );
      const PlusIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          className="w-4 h-4 mr-1"
        >
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
        </svg>
      );
      const TrashIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          className="w-3.5 h-3.5"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.56 0c1.153 0 2.243.032 3.223.094M7.5 5.25l.47-2.742A1.875 1.875 0 019.87 1h4.263a1.875 1.875 0 011.872 1.508l.47 2.742M7.5 5.25M16.5 5.25m0 0v0m0 0v0"
          />
        </svg>
      );
      const PencilIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          className="w-3.5 h-3.5"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 011.13-1.897L16.863 4.487zm0 0L19.5 7.125M12 15v5.25M15 12H9"
          />
        </svg>
      );
      const LoadingSpinner = () => (
        <svg
          className="animate-spin h-4 w-4 text-indigo-500"
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
        >
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path
            className="opacity-75"
            fill="currentColor"
            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          ></path>
        </svg>
      );

      function useLocalStorage(key, initialValue) {
        /* ... (same as before) ... */
        const [storedValue, setStoredValue] = useState(() => {
          try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
          } catch (error) {
            console.error("Error reading LS:", error);
            return initialValue;
          }
        });
        const setValue = (value) => {
          try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
          } catch (error) {
            console.error("Error writing LS:", error);
          }
        };
        return [storedValue, setValue];
      }

      const AppContext = createContext();

      function App() {
        const [apiKey, setApiKey] = useLocalStorage("claritree-apiKey-v2", "");
        const [selectedModel, setSelectedModel] = useLocalStorage("claritree-selectedModel-v2", DEFAULT_MODEL);
        const [showSettings, setShowSettings] = useState(false);
        const [isLoadingAI, setIsLoadingAI] = useState(false);
        const [decisions, setDecisions] = useLocalStorage("claritree-decisions-v2", []);
        const [currentDecisionId, setCurrentDecisionId] = useLocalStorage("claritree-currentDecisionId-v2", null);
        const [selectedPath, setSelectedPath] = useLocalStorage("claritree-selectedPath-v2", []); // Persist selected path for current tree

        const currentDecision = decisions.find((d) => d.id === currentDecisionId);

        useEffect(() => {
          // Clear selected path if decision changes
          if (currentDecisionId && currentDecision) {
            const rootNode = currentDecision.tree.nodes.find((n) => n.isRoot);
            if (
              rootNode &&
              (selectedPath.length === 0 || !currentDecision.tree.nodes.find((n) => n.id === selectedPath[0]))
            ) {
              setSelectedPath([rootNode.id]);
            }
          } else {
            setSelectedPath([]);
          }
        }, [currentDecisionId, currentDecision]);

        const updateCurrentDecisionTree = (newTreeData) => {
          setDecisions((prevDecisions) =>
            prevDecisions.map((d) => (d.id === currentDecisionId ? { ...d, tree: newTreeData } : d))
          );
        };
        const updateDecisionName = (id, newName) =>
          setDecisions((prev) => prev.map((d) => (d.id === id ? { ...d, name: newName } : d)));
        const isSubmitEnabled = !!apiKey;

        const handleInitialSubmit = async (prompt) => {
          if (!isSubmitEnabled || isLoadingAI) return;
          setIsLoadingAI(true);
          try {
            const titlePrompt = `Generate a concise title (max 5 words) for a decision tree about: "${prompt}"`;
            const titleResponse = await callOpenAI(titlePrompt, apiKey, selectedModel, []);
            const decisionName = titleResponse || `Decision: ${prompt.substring(0, 20)}...`;

            const newDecisionId = generateUUID();
            const rootNodeId = generateUUID();
            const initialTree = {
              nodes: [{ id: rootNodeId, text: prompt, x: 0, y: 0, parentId: null, isRoot: true, options: [] }],
              edges: [],
              nodeSpacingX: 220,
              levelSpacingY: 180, // Adjusted for potentially more text
            };

            setDecisions((prev) => [
              ...prev,
              { id: newDecisionId, name: decisionName, createdAt: new Date().toISOString(), tree: initialTree },
            ]);
            setCurrentDecisionId(newDecisionId);
            setSelectedPath([rootNodeId]); // Select the root node to trigger option generation
          } catch (error) {
            console.error("Init decision error:", error);
            alert("Failed to initialize decision.");
          } finally {
            setIsLoadingAI(false);
          }
        };

        const addNewDecision = () => {
          setCurrentDecisionId(null);
          setSelectedPath([]);
        };
        const deleteDecision = (idToDelete) => {
          setDecisions((prev) => prev.filter((d) => d.id !== idToDelete));
          if (currentDecisionId === idToDelete) {
            setCurrentDecisionId(null);
            setSelectedPath([]);
          }
        };

        const appContextValue = {
          apiKey,
          setApiKey,
          selectedModel,
          setSelectedModel,
          isLoadingAI,
          setIsLoadingAI,
          decisions,
          setDecisions,
          currentDecisionId,
          setCurrentDecisionId,
          currentDecision,
          updateCurrentDecisionTree,
          updateDecisionName,
          addNewDecision,
          deleteDecision,
          selectedPath,
          setSelectedPath,
        };

        return (
          <AppContext.Provider value={appContextValue}>
            <div className="h-screen w-screen flex flex-col">
              <Header onSettingsClick={() => setShowSettings(true)} />
              {showSettings && <SettingsModal onClose={() => setShowSettings(false)} />}

              <main className="flex-grow flex overflow-hidden">
                {!currentDecisionId ? (
                  <StartScreen onSubmit={handleInitialSubmit} isSubmitEnabled={isSubmitEnabled} />
                ) : (
                  <MainAppView />
                )}
              </main>
            </div>
          </AppContext.Provider>
        );
      }

      function Header({ onSettingsClick }) {
        return (
          <header className="bg-white border-b border-slate-200 p-3 flex justify-between items-center shadow-sm">
            <h1 className="text-lg font-semibold text-indigo-600">ClariTree AI</h1>
            <button
              onClick={onSettingsClick}
              className="p-1.5 rounded-md hover:bg-slate-100 text-slate-500 hover:text-indigo-600 focus:outline-none transition-colors duration-150"
            >
              <CogIcon />
            </button>
          </header>
        );
      }

      function SettingsModal({ onClose }) {
        const { apiKey, setApiKey, selectedModel, setSelectedModel } = useContext(AppContext);
        const [localApiKey, setLocalApiKey] = useState(apiKey);
        const [localModel, setLocalModel] = useState(selectedModel);
        const handleSave = () => {
          setApiKey(localApiKey);
          setSelectedModel(localModel);
          onClose();
        };

        return (
          <div className="modal-overlay fade-enter-active" onClick={onClose}>
            <div className="modal-content slide-up-enter-active w-11/12 md:w-auto" onClick={(e) => e.stopPropagation()}>
              <h2 className="text-xl font-medium mb-5 text-slate-700">Settings</h2>
              <div className="mb-4">
                <label htmlFor="apiKey" className="block text-xs font-medium text-slate-500 mb-1">
                  OpenAI API Key
                </label>
                <input
                  type="password"
                  id="apiKey"
                  value={localApiKey}
                  onChange={(e) => setLocalApiKey(e.target.value)}
                  className="w-full p-2 text-sm border border-slate-300 rounded-md focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                  placeholder="sk-xxxxxxxxxx"
                />
              </div>
              <div className="mb-5">
                <label htmlFor="modelSelect" className="block text-xs font-medium text-slate-500 mb-1">
                  AI Model
                </label>
                <select
                  id="modelSelect"
                  value={localModel}
                  onChange={(e) => setLocalModel(e.target.value)}
                  className="w-full p-2 text-sm border border-slate-300 rounded-md focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500"
                >
                  <option value="gpt-4o">GPT-4o</option>
                  <option value="gpt-4-turbo">GPT-4 Turbo</option>
                  <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                </select>
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  onClick={onClose}
                  className="px-3 py-1.5 text-sm font-medium text-slate-600 bg-slate-100 rounded-md hover:bg-slate-200 focus:outline-none transition-colors"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSave}
                  className="px-3 py-1.5 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none transition-colors"
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        );
      }

      function StartScreen({ onSubmit, isSubmitEnabled }) {
        const [prompt, setPrompt] = useState("");
        const { isLoadingAI } = useContext(AppContext);
        const handleSubmit = (e) => {
          e.preventDefault();
          if (prompt.trim() && isSubmitEnabled && !isLoadingAI) onSubmit(prompt.trim());
        };

        return (
          <div className="flex-grow flex flex-col items-center justify-center p-4 bg-slate-50">
            <div className="w-full max-w-lg text-center">
              <h2 className="text-3xl font-semibold text-indigo-600 mb-2">Map Your Decisions</h2>
              <p className="text-md text-slate-500 mb-6">Describe your initial problem or decision to begin.</p>
              <form onSubmit={handleSubmit} className="w-full">
                <textarea
                  value={prompt}
                  onChange={(e) => setPrompt(e.target.value)}
                  placeholder="e.g., Choosing a new career path..."
                  rows="3"
                  className="w-full p-3 text-sm border border-slate-300 rounded-lg shadow-sm focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 transition-shadow"
                  disabled={!isSubmitEnabled || isLoadingAI}
                ></textarea>
                <button
                  type="submit"
                  className={`mt-4 w-full md:w-auto px-6 py-2 text-sm font-medium text-white rounded-md shadow-sm focus:outline-none transition-all ${
                    isSubmitEnabled && !isLoadingAI
                      ? "bg-indigo-600 hover:bg-indigo-700 focus:ring-2 focus:ring-indigo-500 focus:ring-offset-1"
                      : "bg-slate-400 cursor-not-allowed"
                  }`}
                  disabled={!isSubmitEnabled || isLoadingAI}
                >
                  {isLoadingAI ? <LoadingSpinner /> : "Start Mapping"}
                </button>
                {!isSubmitEnabled && (
                  <p className="text-xs text-red-500 mt-2">Please set your OpenAI API Key in Settings.</p>
                )}
              </form>
            </div>
          </div>
        );
      }

      function MainAppView() {
        return (
          <div className="flex-grow flex h-full overflow-hidden">
            <LeftSidebar />
            <CanvasView />
            <RightSidebar />
          </div>
        );
      }

      function LeftSidebar() {
        const {
          decisions,
          currentDecisionId,
          setCurrentDecisionId,
          addNewDecision,
          deleteDecision,
          updateDecisionName,
        } = useContext(AppContext);
        const [editingId, setEditingId] = useState(null);
        const [editText, setEditText] = useState("");
        const handleEdit = (decision) => {
          setEditingId(decision.id);
          setEditText(decision.name);
        };
        const handleSaveEdit = (id) => {
          if (editText.trim()) updateDecisionName(id, editText.trim());
          setEditingId(null);
        };
        const formatDate = (iso) => (iso ? new Date(iso).toLocaleDateString("en-CA") : "");

        return (
          <div className="w-64 bg-white border-r border-slate-200 p-3 flex flex-col space-y-3 overflow-y-auto">
            <button
              onClick={addNewDecision}
              className="w-full flex items-center justify-center px-3 py-2 text-xs font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none transition-colors"
            >
              <PlusIcon /> New Decision Map
            </button>
            <h3 className="text-sm font-semibold text-slate-500 mt-2 pt-2 border-t border-slate-100 uppercase tracking-wider">
              My Maps
            </h3>
            {decisions.length === 0 && <p className="text-xs text-slate-400 px-1">No decision maps yet.</p>}
            <ul className="space-y-1">
              {decisions
                .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
                .map((decision) => (
                  <li
                    key={decision.id}
                    onClick={() => setCurrentDecisionId(decision.id)}
                    className={`p-2 rounded-md cursor-pointer group hover:bg-indigo-50 transition-colors ${
                      currentDecisionId === decision.id ? "bg-indigo-100 text-indigo-700 font-medium" : "text-slate-600"
                    }`}
                  >
                    {editingId === decision.id /* ... (edit input logic from before, simplified) ... */ ? (
                      <input
                        type="text"
                        value={editText}
                        onChange={(e) => setEditText(e.target.value)}
                        onBlur={() => handleSaveEdit(decision.id)}
                        onKeyPress={(e) => e.key === "Enter" && handleSaveEdit(decision.id)}
                        className="text-xs p-1 border rounded-md w-full"
                        autoFocus
                      />
                    ) : (
                      <div className="flex justify-between items-center">
                        <div className="flex-grow overflow-hidden">
                          <span className="text-xs block truncate" title={decision.name}>
                            {decision.name}
                          </span>
                          <span className="text-xxs text-slate-400 block">{formatDate(decision.createdAt)}</span>
                        </div>
                        <div className="flex space-x-1.5 opacity-0 group-hover:opacity-100 transition-opacity shrink-0">
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleEdit(decision);
                            }}
                            className="p-0.5 text-slate-400 hover:text-indigo-500"
                          >
                            <PencilIcon />
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              if (window.confirm(`Delete "${decision.name}"?`)) deleteDecision(decision.id);
                            }}
                            className="p-0.5 text-slate-400 hover:text-red-500"
                          >
                            <TrashIcon />
                          </button>
                        </div>
                      </div>
                    )}
                  </li>
                ))}
            </ul>
          </div>
        );
      }

      // --- Canvas View Component (Major AI logic changes here) ---
      function CanvasView() {
        const {
          currentDecision,
          updateCurrentDecisionTree,
          apiKey,
          selectedModel,
          isLoadingAI,
          setIsLoadingAI,
          selectedPath,
          setSelectedPath,
        } = useContext(AppContext);
        const svgRef = useRef(null);
        const [viewBox, setViewBox] = useState("0 0 800 600");
        const [isDragging, setIsDragging] = useState(false);
        const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });
        const [editingNode, setEditingNode] = useState(null); // { nodeId, text } or { nodeId, optionIndex, text }

        const currentTree = currentDecision?.tree;

        // Auto-generate options for the active node if it has none
        useEffect(() => {
          if (!currentTree || !currentTree.nodes || selectedPath.length === 0 || isLoadingAI || !apiKey) return;

          const activeNodeId = selectedPath[selectedPath.length - 1];
          const activeNode = currentTree.nodes.find((n) => n.id === activeNodeId);

          if (
            activeNode &&
            (!activeNode.options || activeNode.options.length === 0) &&
            !activeNode.isGeneratingOptions
          ) {
            // Mark node as generating to prevent re-trigger
            updateCurrentDecisionTree({
              ...currentTree,
              nodes: currentTree.nodes.map((n) => (n.id === activeNodeId ? { ...n, isGeneratingOptions: true } : n)),
            });

            setIsLoadingAI(true);

            // Build context path
            let contextPath = [];
            let currentPathNodeId = activeNodeId;
            for (let i = selectedPath.length - 1; i >= 0; i--) {
              const nodeId = selectedPath[i];
              const nodeInPath = currentTree.nodes.find((n) => n.id === nodeId);
              if (nodeInPath) contextPath.unshift(nodeInPath.text);
              else break;
            }
            const decisionChain = contextPath.join(" -> ");

            const prompt = `Decision path: "${decisionChain}". Focusing on the last step: "${activeNode.text}". What are 3-4 distinct, concise (1-10 words) questions to help make a decision? Stick to holistic views and optimise for resolving the initial action. Format as a numbered list.`;

            callOpenAI(prompt, apiKey, selectedModel, [])
              .then((aiResponse) => {
                const newOptions =
                  aiResponse
                    .match(/\d+\.\s(.*?)(?=(\n\d+\.|$))/g)
                    ?.map((c) => ({ text: c.replace(/\d+\.\s/, "").trim(), targetNodeId: null })) || [];

                updateCurrentDecisionTree({
                  ...currentTree,
                  nodes: currentTree.nodes.map((n) =>
                    n.id === activeNodeId ? { ...n, options: newOptions, isGeneratingOptions: false } : n
                  ),
                });
              })
              .catch((error) => {
                console.error("AI option generation error:", error);
                alert("Failed to generate options. Check console.");
                updateCurrentDecisionTree({
                  // Unset generating flag on error
                  ...currentTree,
                  nodes: currentTree.nodes.map((n) =>
                    n.id === activeNodeId
                      ? {
                          ...n,
                          isGeneratingOptions: false,
                          options: [{ text: "Error generating options - try manual", targetNodeId: null }],
                        }
                      : n
                  ),
                });
              })
              .finally(() => setIsLoadingAI(false));
          }
        }, [selectedPath, currentTree, apiKey, selectedModel, isLoadingAI, updateCurrentDecisionTree, setIsLoadingAI]);

        const positionedTree = useMemo(() => {
          // Recalculate positions when tree changes
          if (!currentTree || !currentTree.nodes) return null;
          // Basic layout logic (same as before, can be improved)
          let newNodes = JSON.parse(JSON.stringify(currentTree.nodes));
          const nodesById = new Map(newNodes.map((n) => [n.id, n]));
          const levels = new Map();
          const nodeLevels = new Map();
          const root = newNodes.find((n) => n.isRoot);
          if (!root) return currentTree;
          const queue = [{ nodeId: root.id, level: 0 }];
          const visited = new Set();
          let maxLevel = 0;
          while (queue.length > 0) {
            const { nodeId, level } = queue.shift();
            if (visited.has(nodeId)) continue;
            visited.add(nodeId);
            if (!levels.has(level)) levels.set(level, []);
            levels.get(level).push(nodeId);
            nodeLevels.set(nodeId, level);
            maxLevel = Math.max(maxLevel, level);
            const node = nodesById.get(nodeId);
            if (node && node.options)
              node.options.forEach((opt) => {
                if (opt.targetNodeId && !visited.has(opt.targetNodeId))
                  queue.push({ nodeId: opt.targetNodeId, level: level + 1 });
              });
          }
          const LEVEL_HEIGHT = currentTree.levelSpacingY || 180;
          const NODE_WIDTH = currentTree.nodeSpacingX || 220;
          newNodes.forEach((node) => {
            const level = nodeLevels.get(node.id);
            node.y = -(level * LEVEL_HEIGHT);
          });
          for (let l = 0; l <= maxLevel; l++) {
            const levelNodeIds = levels.get(l) || [];
            const levelWidth = levelNodeIds.length * NODE_WIDTH;
            const startX = -(levelWidth / 2) + NODE_WIDTH / 2;
            levelNodeIds.forEach((nodeId, index) => {
              const node = nodesById.get(nodeId);
              if (!node) return;
              node.x = startX + index * NODE_WIDTH;
              if (node.parentId && l > 0) {
                const parentNode = nodesById.get(node.parentId);
                if (!parentNode) return;
                const siblings = newNodes.filter((n) => n.parentId === parentNode.id);
                const siblingIndex = siblings.findIndex((s) => s.id === nodeId);
                node.x =
                  parentNode.x +
                  (siblingIndex - (siblings.length - 1) / 2) * (NODE_WIDTH * (siblings.length > 1 ? 0.85 : 1));
              }
            });
          }
          return { ...currentTree, nodes: newNodes };
        }, [currentTree]);

        const handleMouseDown = (e) => {
          /* ... (same pan logic) ... */ if (e.target === svgRef.current) {
            setIsDragging(true);
            setLastMousePos({ x: e.clientX, y: e.clientY });
          }
        };
        const handleMouseMove = (e) => {
          /* ... (same pan logic) ... */ if (!isDragging || !svgRef.current) return;
          const [vx, vy, vw, vh] = viewBox.split(" ").map(parseFloat);
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;
          const zoom = svgRef.current.clientWidth / vw;
          setViewBox(`${vx - dx / zoom} ${vy - dy / zoom} ${vw} ${vh}`);
          setLastMousePos({ x: e.clientX, y: e.clientY });
        };
        const handleMouseUp = () => setIsDragging(false);
        const handleWheel = useCallback(
          (e) => {
            /* ... (same zoom logic, ensure svgRef.current exists) ... */
            if (!svgRef.current) return;
            e.preventDefault();
            const [vx, vy, vw, vh] = viewBox.split(" ").map(parseFloat);
            const zoomFactor = 1.1;
            const { clientX, clientY } = e;
            const svgRect = svgRef.current.getBoundingClientRect();
            const svgX = (clientX - svgRect.left) * (vw / svgRect.width) + vx;
            const svgY = (clientY - svgRect.top) * (vh / svgRect.height) + vy;
            let newVw, newVh;
            if (e.deltaY < 0) {
              newVw = vw / zoomFactor;
              newVh = vh / zoomFactor;
            } else {
              newVw = vw * zoomFactor;
              newVh = vh * zoomFactor;
            }
            const newVx = svgX - (svgX - vx) * (newVw / vw);
            const newVy = svgY - (svgY - vy) * (newVh / vh);
            setViewBox(`${newVx} ${newVy} ${newVw} ${newVh}`);
          },
          [viewBox]
        ); // Added viewBox to dependencies for useCallback

        useEffect(() => {
          const svgEl = svgRef.current;
          if (svgEl) {
            svgEl.addEventListener("wheel", handleWheel, { passive: false });
            return () => svgEl.removeEventListener("wheel", handleWheel);
          }
        }, [handleWheel]);

        const handleOptionSelection = (parentNodeId, optionIndex, optionText) => {
          if (isLoadingAI) return;

          const parentNode = currentTree.nodes.find((n) => n.id === parentNodeId);
          if (!parentNode || !parentNode.options || !parentNode.options[optionIndex]) return;

          // If this option already leads to a node, just select that path
          const existingTargetNodeId = parentNode.options[optionIndex].targetNodeId;
          if (existingTargetNodeId) {
            // Find the path to this existingTargetNodeId and set it
            let pathToTarget = [existingTargetNodeId];
            let curr = currentTree.nodes.find((n) => n.id === existingTargetNodeId);
            while (curr && curr.parentId) {
              const parent = currentTree.nodes.find((n) => n.id === curr.parentId);
              if (parent) {
                pathToTarget.unshift(parent.id);
                curr = parent;
              } else break;
            }
            if (
              selectedPath[0] &&
              !pathToTarget.includes(selectedPath[0]) &&
              currentTree.nodes.find((n) => n.id === selectedPath[0])?.isRoot
            ) {
              pathToTarget.unshift(selectedPath[0]); // Ensure root is part of path if not already
            }
            setSelectedPath(pathToTarget);
            return;
          }

          // Create new node from this option
          const newNodeId = generateUUID();
          const newNode = {
            id: newNodeId,
            text: optionText, // New node's text is the chosen option
            parentId: parentNodeId,
            isRoot: false,
            options: [], // AI will auto-populate this
            x: 0,
            y: 0, // Position will be recalculated
            isGeneratingOptions: false,
          };

          const updatedNodes = [...currentTree.nodes, newNode];
          const updatedEdges = [...currentTree.edges, { from: parentNodeId, to: newNodeId, optionIndex }];

          const finalNodes = updatedNodes.map((n) => {
            if (n.id === parentNodeId) {
              const newOptions = [...n.options];
              newOptions[optionIndex] = { ...newOptions[optionIndex], targetNodeId: newNodeId };
              return { ...n, options: newOptions };
            }
            return n;
          });

          updateCurrentDecisionTree({ ...currentTree, nodes: finalNodes, edges: updatedEdges });
          // Update selectedPath to include the new node, triggering AI for it
          const newSelectedPath = selectedPath.slice(0, selectedPath.indexOf(parentNodeId) + 1);
          newSelectedPath.push(newNodeId);
          setSelectedPath(newSelectedPath);
        };

        // Simplified removeDescendants (same as before)
        const removeDescendants = (startNodeId, nodes, edges) => {
          /* ... */
          let nodesToRemove = new Set();
          let queue = [startNodeId];
          if (nodes.find((n) => n.id === startNodeId)) nodesToRemove.add(startNodeId);
          else return { nodes, edges }; // safety
          while (queue.length > 0) {
            const currId = queue.shift();
            edges
              .filter((e) => e.from === currId)
              .forEach((edge) => {
                if (!nodesToRemove.has(edge.to)) {
                  nodesToRemove.add(edge.to);
                  queue.push(edge.to);
                }
              });
          }
          const newNodes = nodes.filter((n) => !nodesToRemove.has(n.id));
          const newEdges = edges.filter((e) => !nodesToRemove.has(e.from) && !nodesToRemove.has(e.to));
          // Also update options in parent nodes that pointed to removed nodes
          const finalNodes = newNodes.map((n) => ({
            ...n,
            options: n.options?.map((opt) =>
              nodesToRemove.has(opt.targetNodeId) ? { ...opt, targetNodeId: null } : opt
            ),
          }));
          return { nodes: finalNodes, edges: newEdges };
        };

        const handleNodeTextEdit = (nodeId, newText) => {
          if (!newText.trim()) {
            setEditingNode(null);
            return;
          }
          const oldNode = currentTree.nodes.find((n) => n.id === nodeId);
          if (!oldNode || oldNode.text === newText.trim()) {
            setEditingNode(null);
            return;
          }

          let { nodes, edges } = removeDescendants(nodeId, currentTree.nodes, currentTree.edges);
          // The node itself is not removed by removeDescendants if it's the startNodeId, but its children are.
          // So, update its text and clear its options to trigger AI.
          nodes = nodes.map((n) => (n.id === nodeId ? { ...n, text: newText.trim(), options: [] } : n));

          updateCurrentDecisionTree({ ...currentTree, nodes, edges });
          setSelectedPath((prev) => prev.slice(0, prev.indexOf(nodeId) + 1)); // Reselect path up to this node
          setEditingNode(null);
        };

        const handleOptionTextEdit = (nodeId, optionIndex, newText) => {
          if (!newText.trim()) {
            setEditingNode(null);
            return;
          }
          const parentNode = currentTree.nodes.find((n) => n.id === nodeId);
          if (!parentNode) return;
          const oldOption = parentNode.options[optionIndex];
          if (oldOption.text === newText.trim()) {
            setEditingNode(null);
            return;
          }

          let { nodes, edges } = currentTree;
          if (oldOption.targetNodeId) {
            // If this option led to a node, remove that descendant tree
            const result = removeDescendants(oldOption.targetNodeId, currentTree.nodes, currentTree.edges);
            nodes = result.nodes;
            edges = result.edges;
          }
          nodes = nodes.map((n) => {
            if (n.id === nodeId) {
              const newOptions = [...n.options];
              newOptions[optionIndex] = { ...newOptions[optionIndex], text: newText.trim(), targetNodeId: null }; // targetNodeId cleared
              return { ...n, options: newOptions };
            }
            return n;
          });
          updateCurrentDecisionTree({ ...currentTree, nodes, edges });
          setEditingNode(null);
        };

        const addCustomOption = (nodeId) => {
          const newOptionText = prompt("Enter text for your custom option:");
          if (!newOptionText || !newOptionText.trim()) return;
          const updatedNodes = currentTree.nodes.map((n) =>
            n.id === nodeId
              ? { ...n, options: [...(n.options || []), { text: newOptionText.trim(), targetNodeId: null }] }
              : n
          );
          updateCurrentDecisionTree({ ...currentTree, nodes: updatedNodes });
        };

        const deleteOption = (nodeId, optionIndex) => {
          /* ... (similar logic to before, ensure it uses removeDescendants) ... */
          if (!window.confirm("Delete this option and its consequences?")) return;
          const parentNode = currentTree.nodes.find((n) => n.id === nodeId);
          if (!parentNode) return;
          const optToDelete = parentNode.options[optionIndex];

          let { nodes, edges } = currentTree;
          if (optToDelete.targetNodeId) {
            const result = removeDescendants(optToDelete.targetNodeId, nodes, edges);
            nodes = result.nodes;
            edges = result.edges;
          }
          nodes = nodes.map((n) =>
            n.id === nodeId ? { ...n, options: n.options.filter((_, idx) => idx !== optionIndex) } : n
          );
          updateCurrentDecisionTree({ ...currentTree, nodes, edges });
        };

        const handleNodeClick = (nodeId) => {
          let path = [nodeId];
          let currId = nodeId;
          const nodesById = new Map(positionedTree.nodes.map((n) => [n.id, n]));
          let safety = 0;
          while (nodesById.get(currId)?.parentId && safety < 20) {
            const parentId = nodesById.get(currId).parentId;
            path.unshift(parentId);
            currId = parentId;
            safety++;
          }
          // Ensure path starts from root if possible
          const rootNode = positionedTree.nodes.find((n) => n.isRoot);
          if (
            rootNode &&
            path[0] !== rootNode.id &&
            nodesById.has(path[0]) &&
            nodesById.get(path[0]).isRoot === false
          ) {
            // this logic means if the current traced path doesn't start with known root, try to fix
            // for simplicity, if root exists and is not in path, just prepend it.
            // This can be made more robust by ensuring contiguity
            if (path.length > 0 && !path.includes(rootNode.id)) {
              // This logic is simplified. A full trace from root to node clicked might be more robust
              // For now, if root is not first, and first element is not root, prepend root
              // path.unshift(rootNode.id); // This might create disjointed paths; better to re-trace
              // Re-tracing:
              let properPath = [nodeId];
              let nodeToTrace = nodesById.get(nodeId);
              while (nodeToTrace && nodeToTrace.parentId) {
                const parent = nodesById.get(nodeToTrace.parentId);
                if (parent) {
                  properPath.unshift(parent.id);
                  nodeToTrace = parent;
                } else break;
              }
              path = properPath;
            }
          }
          setSelectedPath(path);
        };

        if (!positionedTree || !positionedTree.nodes)
          return (
            <div className="flex-grow canvas-container flex items-center justify-center text-slate-400 text-sm">
              Select or create a decision map.
            </div>
          );

        const NODE_RECT_WIDTH = 180;
        const NODE_RECT_HEIGHT_BASE = 30;
        const OPTION_LINE_HEIGHT = 16;
        const OPTION_ITEM_PADDING_Y = 4;
        const OPTION_AREA_PADDING_TOP = 8;

        return (
          <div
            className="flex-grow canvas-container"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            <svg
              ref={svgRef}
              width="100%"
              height="100%"
              viewBox={viewBox}
              className="cursor-grab active:cursor-grabbing"
            >
              <defs>
                <marker
                  id="arrow"
                  viewBox="0 0 10 10"
                  refX="8"
                  refY="5"
                  markerWidth="5"
                  markerHeight="5"
                  orient="auto-start-reverse"
                >
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#cbd5e1" />
                </marker>
              </defs>
              <g>
                {positionedTree.edges.map((edge, index) => {
                  /* ... (edge rendering, simplified class names) ... */
                  const fromNode = positionedTree.nodes.find((n) => n.id === edge.from);
                  const toNode = positionedTree.nodes.find((n) => n.id === edge.to);
                  if (!fromNode || !toNode) return null;
                  const fromNodeTotalHeight =
                    NODE_RECT_HEIGHT_BASE +
                    OPTION_AREA_PADDING_TOP +
                    (fromNode.options?.length || 0) * (OPTION_LINE_HEIGHT + OPTION_ITEM_PADDING_Y * 2);
                  return (
                    <line
                      key={`edge-${index}`}
                      x1={fromNode.x + NODE_RECT_WIDTH / 2}
                      y1={fromNode.y + fromNodeTotalHeight}
                      x2={toNode.x + NODE_RECT_WIDTH / 2}
                      y2={toNode.y}
                      className={`edge ${
                        selectedPath.includes(fromNode.id) && selectedPath.includes(toNode.id) ? "highlighted-edge" : ""
                      }`}
                      markerEnd_disabled="url(#arrow)"
                      style={{ zIndex: -1 }}
                    />
                  );
                })}
                {positionedTree.nodes.map((node) => {
                  console.log("Rendering node:", node);
                  const isNodeSelected = selectedPath.includes(node.id);
                  const nodeTotalHeight =
                    NODE_RECT_HEIGHT_BASE +
                    OPTION_AREA_PADDING_TOP +
                    ((node.options?.length || 0) + 2 || 0) * (OPTION_LINE_HEIGHT + OPTION_ITEM_PADDING_Y * 1.5) +
                    (node.options?.length > 0 ? 5 : 0); // Approximate
                  const activeNodeInPath = selectedPath[selectedPath.length - 1] === node.id;

                  return (
                    <g
                      key={node.id}
                      transform={`translate(${node.x}, ${node.y})`}
                      className={`transition-opacity duration-200 ${
                        selectedPath.length > 0 && !isNodeSelected ? "desaturated" : ""
                      }`}
                      onClick={() => handleNodeClick(node.id)}
                    >
                      <rect
                        width={NODE_RECT_WIDTH}
                        height={nodeTotalHeight}
                        rx="6"
                        ry="6"
                        className={`node ${isNodeSelected ? "highlighted-node" : ""} shadow-md`}
                      />

                      <foreignObject x="0" y="0" width={NODE_RECT_WIDTH} height={NODE_RECT_HEIGHT_BASE}>
                        <div className="w-full h-full flex items-center justify-center px-2 text-center">
                          {editingNode &&
                          editingNode.nodeId === node.id &&
                          typeof editingNode.optionIndex === "undefined" ? (
                            <input
                              type="text"
                              value={editingNode.text}
                              onChange={(e) => setEditingNode({ ...editingNode, text: e.target.value })}
                              onBlur={() => handleNodeTextEdit(node.id, editingNode.text)}
                              onKeyPress={(e) => e.key === "Enter" && handleNodeTextEdit(node.id, editingNode.text)}
                              className="w-full text-center text-xs p-0.5 border border-indigo-300 rounded bg-white"
                              autoFocus
                            />
                          ) : (
                            <p
                              className="node-text truncate"
                              title={node.text}
                              onDoubleClick={() => setEditingNode({ nodeId: node.id, text: node.text })}
                            >
                              {node.text}
                            </p>
                          )}
                        </div>
                      </foreignObject>

                      {node.isGeneratingOptions && activeNodeInPath && (
                        <foreignObject
                          x={NODE_RECT_WIDTH / 2 - 10}
                          y={NODE_RECT_HEIGHT_BASE + 5}
                          width="20"
                          height="20"
                        >
                          {" "}
                          <LoadingSpinner />{" "}
                        </foreignObject>
                      )}

                      {node.options && node.options.length > 0 && (
                        <foreignObject
                          x="5"
                          y={NODE_RECT_HEIGHT_BASE + OPTION_AREA_PADDING_TOP - 5}
                          width={NODE_RECT_WIDTH - 10}
                          height={nodeTotalHeight - NODE_RECT_HEIGHT_BASE - OPTION_AREA_PADDING_TOP + 10}
                        >
                          <div className="space-y-1 p-1">
                            {node.options.map((option, index) => (
                              <div
                                key={index}
                                className={`option-item p-1 flex justify-between items-center ${
                                  option.targetNodeId && selectedPath.includes(option.targetNodeId)
                                    ? "bg-indigo-100"
                                    : ""
                                }`}
                                onClick={(e) => {
                                  e.stopPropagation();
                                  handleOptionSelection(node.id, index, option.text);
                                }}
                              >
                                {editingNode && editingNode.nodeId === node.id && editingNode.optionIndex === index ? (
                                  <input
                                    type="text"
                                    value={editingNode.text}
                                    onChange={(e) => setEditingNode({ ...editingNode, text: e.target.value })}
                                    onBlur={() => handleOptionTextEdit(node.id, index, editingNode.text)}
                                    onKeyPress={(e) =>
                                      e.key === "Enter" && handleOptionTextEdit(node.id, index, editingNode.text)
                                    }
                                    className="flex-grow text-xs p-0.5 border border-indigo-300 rounded bg-white"
                                    autoFocus
                                  />
                                ) : (
                                  <span
                                    className="option-text text-xs truncate"
                                    title={option.text}
                                    onDoubleClick={(e) => {
                                      e.stopPropagation();
                                      setEditingNode({ nodeId: node.id, optionIndex: index, text: option.text });
                                    }}
                                  >
                                    {option.text} {option.targetNodeId ? "✓" : ""}
                                  </span>
                                )}
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    deleteOption(node.id, index);
                                  }}
                                  className="p-0.5 text-slate-400 hover:text-red-500 opacity-50 hover:opacity-100"
                                >
                                  <TrashIcon />
                                </button>
                              </div>
                            ))}
                          </div>
                        </foreignObject>
                      )}
                      <foreignObject x={NODE_RECT_WIDTH - 28} y={nodeTotalHeight - 18} width="24" height="16">
                        <button
                          title="Add custom option"
                          onClick={(e) => {
                            e.stopPropagation();
                            addCustomOption(node.id);
                          }}
                          className="p-0.5 text-indigo-400 hover:text-indigo-600 text-xs"
                        >
                          <PlusIcon />
                        </button>
                      </foreignObject>
                    </g>
                  );
                })}
              </g>
            </svg>
            {isLoadingAI && !positionedTree?.nodes.find((n) => n.isGeneratingOptions) && (
              <div className="absolute top-2 right-2 bg-white p-1.5 rounded shadow text-xs text-indigo-600 flex items-center">
                <LoadingSpinner /> <span className="ml-1.5">AI is working...</span>
              </div>
            )}
          </div>
        );
      }

      function RightSidebar() {
        const { currentDecision, selectedPath } = useContext(AppContext);
        const [summaryItems, setSummaryItems] = useState([]);

        useEffect(() => {
          if (!currentDecision?.tree?.nodes || selectedPath.length === 0) {
            setSummaryItems([]);
            return;
          }
          const items = [];
          const nodesById = new Map(currentDecision.tree.nodes.map((n) => [n.id, n]));

          for (let i = 0; i < selectedPath.length; i++) {
            const nodeId = selectedPath[i];
            const node = nodesById.get(nodeId);
            if (!node) continue;
            items.push({ type: i === 0 ? "Decision" : "Path Step", text: node.text, depth: i });

            if (i === selectedPath.length - 1 && node.options && node.options.length > 0) {
              // Last node in path
              items.push({ type: "Next Options", text: "Available next steps:", depth: i + 1, isHeader: true });
              node.options.forEach((opt) =>
                items.push({ type: "Option", text: opt.text, depth: i + 1, explored: !!opt.targetNodeId })
              );
            }
          }
          setSummaryItems(items);
        }, [selectedPath, currentDecision]);

        return (
          <div className="w-72 bg-white border-l border-slate-200 p-3 overflow-y-auto">
            <h3 className="text-sm font-semibold text-slate-500 mb-2 uppercase tracking-wider">Path Summary</h3>
            {summaryItems.length === 0 ? (
              <p className="text-xs text-slate-400 px-1">Select a node on the map to see its path.</p>
            ) : (
              <ul className="space-y-0.5">
                {summaryItems.map((item, index) => (
                  <li
                    key={index}
                    style={{ marginLeft: `${item.depth * 0.5}rem` }}
                    className={`p-1.5 rounded-md text-xs ${
                      item.isHeader
                        ? "font-medium text-slate-500 mt-1"
                        : item.type === "Decision"
                        ? "bg-indigo-50 text-indigo-700 font-medium"
                        : item.type === "Path Step"
                        ? "bg-slate-100 text-slate-600"
                        : "text-slate-500 hover:bg-slate-50"
                    } ${item.explored ? "opacity-70" : ""}`}
                  >
                    {item.type === "Option" && <span className="mr-1 opacity-60">{item.explored ? "✓" : "•"}</span>}
                    {item.text}
                  </li>
                ))}
              </ul>
            )}
          </div>
        );
      }

      async function callOpenAI(prompt, apiKey, model, messagesHistory = []) {
        /* ... (same as before, ensure error details are good) ... */
        if (!apiKey) throw new Error("API Key is not set.");
        const messages = [
          {
            role: "system",
            content:
              "You are a concise assistant helping brainstorm decision options. Provide answers as a numbered list. Each item should be brief.",
          },
          ...messagesHistory,
          { role: "user", content: prompt },
        ];
        try {
          const response = await fetch(OPENAI_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json", Authorization: `Bearer ${apiKey}` },
            body: JSON.stringify({ model, messages, max_tokens: 200 }),
          });
          if (!response.ok) {
            const errData = await response.json();
            throw new Error(`API Error (${response.status}): ${errData.error?.message || response.statusText}`);
          }
          const data = await response.json();
          return data.choices[0]?.message?.content.trim() || "";
        } catch (error) {
          console.error("OpenAI call error:", error);
          throw error;
        }
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
